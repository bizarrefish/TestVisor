using System;

using Bizarrefish.WebLib;

using System.Collections.Generic;
using System.Web.Script.Serialization;
using System.Threading;
using System.Reflection;
using System.Linq;

namespace Bizarrefish.WebLib
{
	public delegate TResponse AjaxFunction<TRequest, TSession, TResponse>(TRequest request, TSession session);
	
	/// <summary>
	/// This manages a collection of live Ajax Modules.
	/// It also generates javascript method stubs.
	/// </summary>
	public interface IAjaxHandler<TSession>
	{
		void AddClass<TClass>();

		/// <summary>
		/// Generates a javascript library with method stubs for all added modules.
		/// </summary>
		string GetJavascript();

	}

	public interface IAjaxMethod<TSession, TResponse>
	{
		TResponse Call(TSession session);
	}

	public class AjaxHandler<TSession> : IAjaxHandler<TSession>
		where TSession : new()
	{
		IDictionary<string, TaskRunner<object>> tasks = new Dictionary<string, TaskRunner<object>>();

		IDictionary<string, string[]> funcFields = new Dictionary<string, string[]>();

		long keyCounter = 0;

		HTTPServer<TSession> server;

		public AjaxHandler(HTTPServer<TSession> server)
		{
			this.server = server;
		}


		public void AddClass<TClass>()
		{
			Type t = typeof(TClass);
			var nested = t.GetNestedTypes();

			foreach(var type in nested)
			{
				var requestType = type;

				Type iFaceType = type.GetInterfaces().FirstOrDefault();
				if(iFaceType.GetGenericTypeDefinition() == typeof(IAjaxMethod<,>))
				{
					string methodName = t.Name + "_" + type.Name;


					Func<object, TSession, object> theFunc = delegate(object reqObj, TSession session)
					{
						object[] pars = new object[] { session };
						return requestType.GetMethod("Call").Invoke (reqObj, pars);
					};

					Type rType = typeof(JSONRequest<>).MakeGenericType(new[] { requestType });

					server.AddCallback(methodName, delegate(TSession session, string reqString)
					{

						JSONResponse jresp = new JSONResponse();

						object jreq = Utils.DeserializeToType(reqString, rType);
						if(jreq == null) jreq = Activator.CreateInstance(requestType);

						string reqKey = JSONRequest<object>.GetKey(jreq);
						object argsObj = JSONRequest<object>.GetArgs(jreq);
						TaskRunner<object> runner = null;
						
						bool newRunner = false;
						
						if(reqKey == null)
						{
							// New request
							runner = new TaskRunner<object>(() => theFunc(argsObj, session));
							// At this point, we may or may not have already completed the task
							reqKey = (keyCounter++).ToString ();
							newRunner = true;
						}
						else if (!tasks.TryGetValue(reqKey, out runner))
							throw new Exception("Invalid Request Key");
						
						// We send the key back with the response.
						jresp.Key = reqKey;
						
						bool error = false;
						if(runner.CheckDone(ref error, ref jresp.Result, ref jresp.ErrorText))
						{
							jresp.Status = (error ? ResponseStatus.ERROR : ResponseStatus.SUCCESS).ToString();
						}
						else
						{
							// This is gonna take a while
							
							// If we only just started this task,
							// stick it in the dictionary
							if(newRunner) tasks[reqKey] = runner;
							
							// We're busy now.
							jresp.Status = ResponseStatus.BUSY.ToString();
						}

						return Utils.Serializer.Serialize(jresp);
					});

					funcFields[methodName] = requestType
						.GetFields()
						.Select (f => f.Name)
							.ToArray();
				}
			}

		}

		public string GetJavascript ()
		{
			return
				"// Autogenerated RPC code:\n" +
				Utils.GenRPC + "\n" +
				funcFields.Aggregate("", (acc, f) => acc = acc + "\n" +
					                     Utils.MakeJavascript(server.GetCallbackUrl(f.Key), f.Key, f.Value));
		}
	}
}

