using System;

using Bizarrefish.WebLib;

using System.Collections.Generic;
using System.Web.Script.Serialization;
using System.Threading;
using System.Reflection;
using System.Linq;

namespace Bizarrefish.WebLib
{
	public delegate TResponse AjaxFunction<TRequest, TSession, TResponse>(TRequest request, TSession session);
	
	/// <summary>
	/// This manages a collection of live Ajax Modules.
	/// It also generates javascript method stubs.
	/// </summary>
	public interface IAjaxHandler<TSession>
	{
		/// <summary>
		/// Add an ajax module
		/// </summary>
		void AddEndpoint<TRequest, TResponse>(string endpointName, AjaxFunction<TRequest, TSession, TResponse> func)
			where TRequest : class
			where TResponse : class;
		
		/// <summary>
		/// Generates a javascript library with method stubs for all added modules.
		/// </summary>
		string GetJavascript();
		
		/// <summary>
		/// Handle a request.
		/// This is absolutely non-blocking.
		/// </summary>
		string Handle(string url, TSession session, string req); 
	}
	
	class JSFunction
	{
		public Type RequestType;
		public Type ResponseType;
		public Func<object, object, object> Function;
		public string Name;
		
		public static JSFunction Create<TRequest, TSession, TResponse>(string name, Func<TRequest, TSession, TResponse> func)
			where TRequest : class
			where TResponse : class
		{
			return new JSFunction()
			{
				RequestType = typeof(TRequest),
				ResponseType = typeof(TResponse),
				Name = name,
				Function = delegate(object oReq, object oSession) {
					TRequest req = oReq as TRequest;
					TSession session = (TSession)oSession;
					return func(req, session);
				}
			};
		}
	}
	
	public class AjaxHandler<TSession> : IAjaxHandler<TSession>
	{
		IDictionary<string, TaskRunner<object>> tasks = new Dictionary<string, TaskRunner<object>>();
		
		IDictionary<string, JSFunction> funcs = new Dictionary<string, JSFunction>();
		
		long keyCounter = 0;
		
		public void AddEndpoint<TRequest, TResponse> (string endpointName, AjaxFunction<TRequest, TSession, TResponse> func)
			where TRequest : class
			where TResponse : class
		{
			// Wrap in serialization stuff...
			funcs["/" + endpointName] = JSFunction.Create<TRequest, TSession, TResponse>(endpointName, (r, s) => func(r, s));
		}

		public string GetJavascript ()
		{
			return
				"// Autogenerated RPC code:\n" +
				Utils.GenRPC + "\n" +
				funcs.Values.Aggregate("", (acc, f) => acc = acc + "\n" + Utils.MakeJavascript(f));
		}
		
		/// <summary>
		/// Handle the specified request for a url.
		/// 
		/// A request packet is as follows:
		/// {
		/// 	Args : { paramName : paramValue, ...},
		/// 	Key : requestKey
		/// }
		/// 
		/// A response packet:
		/// {
		/// 	Status: ("BUSY"|"SUCCESS"|"ERROR"),
		/// 	Result: {},
		/// 	ErrorText: "",
		/// 	Key: requestKey
		/// }
		/// </summary>
		public string Handle (string url, TSession session, string req)
		{
			
			JSFunction jsf;
			JSONResponse jresp = new JSONResponse();
			
			try
			{	
				if(funcs.TryGetValue(url, out jsf))
				{
					
					Type rType = typeof(JSONRequest<>).MakeGenericType(new[] { jsf.RequestType });
					
					object jreq = Utils.DeserializeToType(req, rType);
					
					string reqKey = JSONRequest<object>.GetKey(jreq);
					object argsObj = JSONRequest<object>.GetArgs(jreq);
					
					if(reqKey == null)
					{
						// New request
						var runner = new TaskRunner<object>(() => jsf.Function(argsObj, session));
						
						jresp.Status = ResponseStatus.BUSY.ToString();
						jresp.Key = (keyCounter++).ToString();
						jresp.ErrorText = "";
						jresp.Result = null;
						
						tasks[jresp.Key] = runner;
						return Utils.Serializer.Serialize(jresp);
					}
					else
					{
						// Polling
						TaskRunner<object> runner;
						if(tasks.TryGetValue(reqKey, out runner))
						{
							jresp.Key = reqKey;
							bool error = false;
							if(runner.CheckDone(ref error, ref jresp.Result, ref jresp.ErrorText))
							{
								jresp.Status = (error ? ResponseStatus.ERROR : ResponseStatus.SUCCESS).ToString();
								
							}
							else
							{
								jresp.Status = ResponseStatus.BUSY.ToString();
							}
						}
						else throw new Exception("Invalid key");
					}
					
				}
				else throw new Exception("Invalid function: " + url);
			}
			catch(Exception e)
			{
				jresp.ErrorText = e.Message;
				jresp.Status = ResponseStatus.ERROR.ToString();
			}
			
			return Utils.Serializer.Serialize(jresp);
		}
	}
}

