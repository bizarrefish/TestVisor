using System;

using Bizarrefish.WebLib;

using System.Collections.Generic;
using System.Web.Script.Serialization;
using System.Threading;
using System.Reflection;
using System.Linq;

namespace Bizarrefish.WebLib
{
	public delegate TResponse AjaxFunction<TRequest, TSession, TResponse>(TRequest request, TSession session);
	
	/// <summary>
	/// This manages a collection of live Ajax Modules.
	/// It also generates javascript method stubs.
	/// </summary>
	public interface IAjaxHandler<TSession>
	{
		/// <summary>
		/// Add an ajax module
		/// </summary>
		void AddEndpoint<TRequest, TResponse>(string endpointName, AjaxFunction<TRequest, TSession, TResponse> func)
			where TRequest : class
			where TResponse : class;

		void AddClass<TClass>();

		/// <summary>
		/// Generates a javascript library with method stubs for all added modules.
		/// </summary>
		string GetJavascript();
		
		/// <summary>
		/// Handle a request.
		/// This is absolutely non-blocking.
		/// </summary>
		string Handle(string url, TSession session, string req); 
	}

	class JSFunction
	{
		public Type RequestType;
		public Type ResponseType;
		public Func<object, object, object> Function;
		public string Name;

		public static JSFunction Create<TRequest, TSession, TResponse>(string name, Func<TRequest, TSession, TResponse> func)
			where TRequest : class
			where TResponse : class
		{
			return new JSFunction()
			{
				RequestType = typeof(TRequest),
				ResponseType = typeof(TResponse),
				Name = name,
				Function = delegate(object oReq, object oSession) {
					TRequest req = oReq as TRequest;
					TSession session = (TSession)oSession;
					return func(req, session);
				}
			};
		}
	}


	public interface IAjaxMethod<TSession, TResponse>
	{
		TResponse Call(TSession session);
	}

	public class AjaxHandler<TSession> : IAjaxHandler<TSession>
	{
		IDictionary<string, TaskRunner<object>> tasks = new Dictionary<string, TaskRunner<object>>();
		
		IDictionary<string, JSFunction> funcs = new Dictionary<string, JSFunction>();
		
		long keyCounter = 0;

		
		public void AddEndpoint<TRequest, TResponse> (string endpointName, AjaxFunction<TRequest, TSession, TResponse> func)
			where TRequest : class
			where TResponse : class
		{
			// Wrap in serialization stuff...
			funcs["/" + endpointName] = JSFunction.Create<TRequest, TSession, TResponse>(endpointName, (r, s) => func(r, s));
		}

		public void AddClass<TClass>()
		{
			Type t = typeof(TClass);
			var nested = t.GetNestedTypes();

			foreach(var type in nested)
			{
				var requestType = type;

				Type iFaceType = type.GetInterfaces().FirstOrDefault();
				if(iFaceType.GetGenericTypeDefinition() == typeof(IAjaxMethod<,>))
				{
					string methodName = t.Name + "_" + type.Name;
					Type respType = iFaceType.GetGenericArguments()[0];
					JSFunction jsf = new JSFunction();
					jsf.Name = methodName;
					jsf.RequestType = type;
					jsf.ResponseType = respType;
					jsf.Function = delegate(object req, object session)
					{
						object[] pars = new[] { session };
						return requestType.GetMethod ("Call").Invoke(req, pars);
					};

					funcs["/" + methodName] = jsf;
				}
			}

		}

		public string GetJavascript ()
		{
			return
				"// Autogenerated RPC code:\n" +
				Utils.GenRPC + "\n" +
				funcs.Values.Aggregate("", (acc, f) => acc = acc + "\n" + Utils.MakeJavascript(f));
		}
		
		/// <summary>
		/// Handle the specified request for a url.
		/// 
		/// A request packet is as follows:
		/// {
		/// 	Args : { paramName : paramValue, ...},
		/// 	Key : requestKey
		/// }
		/// 
		/// A response packet:
		/// {
		/// 	Status: ("BUSY"|"SUCCESS"|"ERROR"),
		/// 	Result: {},
		/// 	ErrorText: "",
		/// 	Key: requestKey
		/// }
		/// </summary>
		public string Handle (string url, TSession session, string req)
		{
			
			JSFunction jsf;
			JSONResponse jresp = new JSONResponse();
			
			try
			{	
				if(funcs.TryGetValue(url, out jsf))
				{
					
					Type rType = typeof(JSONRequest<>).MakeGenericType(new[] { jsf.RequestType });
					
					object jreq = Utils.DeserializeToType(req, rType);
					if(jreq == null) jreq = Activator.CreateInstance(rType);

					string reqKey = JSONRequest<object>.GetKey(jreq);
					object argsObj = JSONRequest<object>.GetArgs(jreq);
					
					TaskRunner<object> runner = null;
					
					bool newRunner = false;
					
					if(reqKey == null)
					{
						// New request
						runner = new TaskRunner<object>(() => jsf.Function(argsObj, session));
						// At this point, we may or may not have already completed the task
						reqKey = (keyCounter++).ToString ();
						newRunner = true;
					}
					else if (!tasks.TryGetValue(reqKey, out runner))
						throw new Exception("Invalid Request Key");
					
					// We send the key back with the response.
					jresp.Key = reqKey;
					
					bool error = false;
					if(runner.CheckDone(ref error, ref jresp.Result, ref jresp.ErrorText))
					{
						jresp.Status = (error ? ResponseStatus.ERROR : ResponseStatus.SUCCESS).ToString();
					}
					else
					{
						// This is gonna take a while
						
						// If we only just started this task,
						// stick it in the dictionary
						if(newRunner) tasks[reqKey] = runner;
						
						// We're busy now.
						jresp.Status = ResponseStatus.BUSY.ToString();
					}
				}
				else throw new Exception("Invalid function: " + url);
			}
			catch(Exception e)
			{
				jresp.ErrorText = e.Message;
				jresp.Status = ResponseStatus.ERROR.ToString();
			}
			
			return Utils.Serializer.Serialize(jresp);
		}
	}
}

